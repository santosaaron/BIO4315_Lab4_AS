---
title: "lab4_transcriptomics"
output: html_document
date: "2025-09-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

# SET-UP
### Download reference genome from refseq (occurs in terminal)
```{bash, eval = FALSE}
curl -O https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/735/GCF_000001735.4_TAIR10.1/GCF_000001735.4_TAIR10.1_genomic.fna.gz

gunzip /Users/aaronsantos/GCF_000001735.4_TAIR10.1_genomic.fna.gz
```

### Download GFF file (occurs in terminal)
```{bash, eval = FALSE}
curl -O https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/735/GCF_000001735.4_TAIR10.1/GCF_000001735.4_TAIR10.1_genomic.gtf.gz

gunzip /Users/aaronsantos/GCF_000001735.4_TAIR10.1_genomic.gtf.gz
```

```{r}
BiocManager::install("clusterProfiler")
```
```{r}
BiocManager::install("EnhancedVolcano")
```
```{r}
BiocManager::install("biomaRt")
```
```{r}
lapply(c(
  "docopt", "DT", "pheatmap","GenomicFeatures", "DESeq2",
  "edgeR", "systemPipeR", "systemPipeRdata", "BiocStyle", "GO.db", "dplyr",
  "tidyr", "stringr", "Rqc", "QuasR", "DT", "ape", "clusterProfiler","biomaRt","EnhancedVolcano"
), require, character.only = TRUE)
```

### 5.1 - Accessing RNAseq data and sample data
```{r}
#get the path 
fq_path <- systemPipeRdata::pathList()$fastqdir

#list the files 
fq_files <- list.files(fq_path)

print(fq_files) #list of file names
#print(class(fq_files))
#print(typeof(fq_files))
```
### import meta data = tells us what sample corresponds to what file name
```{r}
meta_data <- read.table(
  system.file("extdata", "param", "targetsPE.txt", package = "systemPipeRdata"),
  header = TRUE
)
#systemPipeRdata is the package that contains the meta data -> goes through
#extdata folder -> param folder -> gets to actual file containing meta data = 
#targetsPE.txt

#36 files for 18 samples = contains BOTH 1x forward + 1x reverse read

head(meta_data)
```

# QUESTION 1
```{r}
library(DT)

#replace ./data/ in each file name of meta data table

#basename = returns file name (w/o folder path)
#file.path = assigns fq_path to all of the files w/in FileName1 column
meta_data$FileName1 <- file.path(fq_path, basename(meta_data$FileName1))
meta_data$FileName2 <- file.path(fq_path, basename(meta_data$FileName2))

DT::datatable(meta_data, options = list(pageLength = 10)) 
#SHOWS ./data/ has been replaced
#should look lime /library/framework...
```
TROUBLESHOOTING - to double check if above methods worked
```{r}
#head(meta_data$FileName1)   #what you see now

#head(basename(meta_data$FileName1))  #see what basename() returns

#head(file.path(fq_path, basename(meta_data$FileName1)))  #final result
```

### 5.2 - Read Processing
# QUESTION 2
```{r}
library(Rqc)

qc_result <- rqc(path = fq_path, pattern = ".fastq.gz", openBrowser = FALSE)
#qc_result is the report
```
```{r}
#generate 3/CYCLE QUALITY box plot
rqcCycleQualityBoxPlot(qc_result[1:12]) + theme_bw()
rqcCycleQualityBoxPlot(qc_result[13:24]) + theme_bw()
rqcCycleQualityBoxPlot(qc_result[25:36]) + theme_bw()
```
Recall: number of cycles (=) number of reads
Visually speaking, the following samples had the longest reads (of about 101 reads/cycles): 028, 030, 032
All other reads were shorter than that of the aforementioned (having about 75 reads/cycles)
```{r}
#generate 3/BASE CALLS box plot
rqcCycleBaseCallsPlot(qc_result[1:12]) + theme_bw()
rqcCycleBaseCallsPlot(qc_result[13:24]) + theme_bw()
rqcCycleBaseCallsPlot(qc_result[25:36]) + theme_bw()
```
Visually speaking, no samples have distinct N calls (no yellow lines are prominent)

# QUESTION 3
```{r}
library(QuasR)

if (!dir.exists("processed_reads")) 
  dir.create("processed_reads")

process_reads <- function(file_path) {
  
  #process fastq file given file path
  result <- readFastq(file_path)
  
  adapter_seq <- "GCCCGGGTAA"
  
  #remove adapater seq
  result_trimmed <- trimLRPatterns(Rpattern = adapter_seq, subject = result)
  
  #remove last 3 bases
  length_trimmed <- width(result_trimmed) - 3 #returns new length of seq
  result_trimmed <- narrow(result_trimmed, start=1, end=length_trimmed) 
  #narrow = returns subseq from start -> end = excludes last 3 bases
  
  #extract actual seq from file 
  actual_seq <- sread(result_trimmed)
  
  #count num of times N appears in seq
  n_count <- vcountPattern("N", actual_seq) #number vec
  
  result_filtered <- result_trimmed[n_count < 1]
  #only returns subset if meets condition -> auto discards result if condition not met
  
  file_name <- basename(file_path)
  
  out_file <- file.path("processed_reads", paste0(file_name, "_processed.fastq")) #update file name
  #paste0 = concat w/o space
  
  #write file to processed_reads folder
  writeFastq(result_filtered, out_file, compress = FALSE, mode = "w")
  
  return(out_file)
}

for (i in seq_len(nrow(meta_data))) 
#length of nrows fine = don't need to look @ reverse
{
  old_path <- meta_data$FileName1[i]
  new_path <- process_reads(old_path)
  meta_data$FileName1[i] <- new_path #update the file path
}
```
Double check metadata table was updated
```{r}
head(meta_data)
```

### 5.3 Alignments
### 5.3.1 - Indexing reference genome = A thaliana genome (TAIR10.1) 
```{r}
#create the output directory for .ht2 files
dir.create("./hisat2_index", recursive = TRUE)

at_genome <- "/Users/aaronsantos/BIO4315/BIO4315_Lab4_AS/GCF_000001735.4_TAIR10.1_genomic.fna"

```
```{r}
tryCatch({system2(command = "/opt/anaconda3/bin/hisat2-build", 
        args = c("-p","8", at_genome,
                 "./hisat2_index/tair10_1_index"),
        stdout = TRUE, stderr = TRUE)}, error = function(e) {
        paste("hisat2-build", "indexing failed with error:", e$message)
      })
#./hisat2_index = output folder
#tair10_1_index = BASE NAME for INDEX FILES
```
TROUBLESHOOTING
```{r}
#check ref genome exists -> should return TRUE
file.exists(at_genome)
```
```{r}
#check if R has permission to output directory -> should return 0 if writable
file.access("./hisat2_index", mode = 2)
```
```{r}
res <- system2("hisat2-build", args = c("-p","8", at_genome, "./hisat2_index/tair10_1_index"), stdout = TRUE, stderr = TRUE)
cat(res, sep = "\n")
```
### 5.3.2 - Mapping reads to indexed genome
# QUESTION 4
```{r}
#MAKE SURE TO CREATE sam/bam_files DIRECTORIES FIRST
#full path to tools
hisat2_path <- "/opt/anaconda3/bin/hisat2"        # change if needed
samtools_path <- "/opt/homebrew/bin/samtools"     # working version

hisat2_index <- "/Users/aaronsantos/BIO4315/BIO4315_Lab4_AS/hisat2_index/tair10_1_index"
sam_folder <- "sam_files"
bam_folder <- "bam_files"

for (folder in c(sam_folder, bam_folder)) {
  if (!dir.exists(folder)) dir.create(folder, recursive = TRUE)
}

#loop over samples
for (i in seq_len(nrow(meta_data))) {
  
  sample_name <- meta_data$SampleName[i]
  fastq_file <- meta_data$FileName1[i]
  
  sam_file <- file.path(sam_folder, paste0(sample_name, ".sam"))
  bam_file <- file.path(bam_folder, paste0(sample_name, ".bam"))
  sorted_bam_file <- file.path(bam_folder, paste0(sample_name, "_sorted.bam"))
  log_file <- file.path(bam_folder, paste0(sample_name, "_hisat2.log"))
  
  #check FASTQ exists
  if (!file.exists(fastq_file)) {
    message("Skipping ", sample_name, ": FASTQ not found at ", fastq_file)
    next
  }
  
  #run HISAT2
  hisat2_log <- tryCatch({
    system2(
      hisat2_path,
      args = c("-x", hisat2_index, "-U", fastq_file, "-p", "8", "-S", sam_file),
      stdout = TRUE,
      stderr = TRUE
    )
  }, error = function(e) paste("HISAT2 failed:", e$message))
  
  #write HISAT2 log
  writeLines(hisat2_log, log_file)
  
  #check SAM created
  if (!file.exists(sam_file) || file.size(sam_file) == 0) {
    message("Skipping ", sample_name, ": SAM file missing or empty. Check log: ", log_file)
    next
  }
  message("SAM created: ", sam_file)
  
  #convert SAM -> BAM
  tryCatch({
    system2(samtools_path, args = c("view", "-bS", sam_file, "-o", bam_file))
    if (!file.exists(bam_file) || file.size(bam_file) == 0) {
      stop("BAM creation failed")
    }
    message("BAM created: ", bam_file)
  }, error = function(e) {
    message("Skipping ", sample_name, ": ", e$message)
    next
  })
  
  #sort BAM
  tryCatch({
    system2(samtools_path, args = c("sort", "-o", sorted_bam_file, bam_file))
    if (!file.exists(sorted_bam_file)) stop("Sorting failed")
    message("Sorted BAM created: ", sorted_bam_file)
  }, error = function(e) {
    message("Skipping ", sample_name, ": ", e$message)
    next
  })
  
  #index sorted BAM
  tryCatch({
    system2(samtools_path, args = c("index", sorted_bam_file))
    if (!file.exists(paste0(sorted_bam_file, ".bai"))) stop("Indexing failed")
    message("Indexed BAM: ", sorted_bam_file, ".bai")
  }, error = function(e) {
    message("Skipping ", sample_name, ": ", e$message)
    next
  })
  
  # Optionally update metadata
  meta_data$SortedBAM[i] <- sorted_bam_file
}

```


###5.3.4 Reading Alignment Stats
```{r}
# get the folder
hisat2_logs_dir <- "./bam_files"

# 1. Get a list of all HISAT2 log files
log_files <- list.files(hisat2_logs_dir, pattern = "\\.hisat2\\.log$", full.names = TRUE)

#preper an "empty" vector of the apropreate size, faster than appending. 
percent_aligned <- 1:length(log_files)

#loop through log files
for (i in seq_along(percent_aligned)) {
  
  percent_aligned[i] <- readLines(log_files[i])[length(readLines(log_files[i]))]
  
}

#bind vectors as dataframe
align_df <- data.frame(sort(meta_data$SampleName),percent_aligned)

# extract the numeric percent value
align_df <- align_df %>% 
  mutate(percent_aligned = as.numeric(
    stringr::str_split_i(align_df$percent_aligned, "%",1))) %>% 
  rename(samplename = sort.meta_data.SampleName.)

head(align_df)
```

```{r}
library(dplyr)
library(stringr)

hisat2_logs_dir <- "./bam_files"

log_files <- list.files(hisat2_logs_dir, pattern = "_hisat2\\.log$", full.names = TRUE)

if(length(log_files) == 0) stop("No HISAT2 log files found!")

# Read last line from each log
percent_aligned <- sapply(log_files, function(f) {
  lines <- readLines(f)
  tail(lines, 1)
})

align_df <- data.frame(
  samplename = sort(meta_data$SampleName),
  percent_aligned = percent_aligned,
  stringsAsFactors = FALSE
)

# Extract numeric percentage
align_df <- align_df %>%
  mutate(percent_aligned = as.numeric(str_split_i(percent_aligned, "%", 1)))

head(align_df)

```

# QUESTION 5
```{r}
DT::datatable(align_df, 
              colnames = c("Sample Name", "Percent Aligned"), 
              options = list(pageLength = 10, autoWidth = TRUE))
```
GGPLOT:
```{r}
ggplot(align_df, aes(x = "", y = percent_aligned)) + 
  geom_boxplot(fill = "darkgreen", color = "lightgreen") + 
  labs(title = "Distribution of Alignment Percentages",
       y = "Percent Aligned (%)",
       x = "") +
  theme_minimal() +
  theme(axis.text.x = element_blank())
```

### 5.4 - Counting number of reads mapped for each gene
```{r}
BiocManager::install("Rsubread")
```
```{r}
#list bam files
bfiles <- list.files("/Users/aaronsantos/BIO4315/BIO4315_Lab4_AS/bam_files", pattern = "_sorted.bam$", full.names = TRUE) #directoreis slightly changed 

#Counting how many reads corespond to each gene
gene_count_list <- Rsubread::featureCounts(files = bfiles, annot.ext = "GCF_000001735.4_TAIR10.1_genomic.gtf", 
                        isGTFAnnotationFile = TRUE, # <--- input annotation is GTF
                        allowMultiOverlap = FALSE,  # <--- don't allow reads that overlap with multiple loci
                        isPairedEnd = FALSE, nthreads = 8,
                        minMQS = 10, # <--- minimum mapping quality score of 10 (like a phred score for the hisat2 alignment)
                        GTF.featureType = "exon",  # <--- Count reads overlapping 'exon' features
                        GTF.attrType = "gene_id" # <--- Groups exon by gene id
                        )
```
### COUNT TABLE:
```{r}
glimpse(gene_count_list$counts)[1:5,1:5]
```
### ANNOTATION TABLE:
```{r}
glimpse(gene_count_list$annotation)[1:5,]
```
### STATS TABLE:
```{r}
glimpse(gene_count_list$stat)[,1:5]
```

# QUESTION 6
```{r}

library(Rsubread)
library(DT)

bam_files <- list.files("./bam_files", pattern = "_sorted.bam$", full.names = TRUE)
gtf_file <- "GCF_000001735.4_TAIR10.1_genomic.gtf"

gene_counts <- featureCounts(
  files = bam_files,
  annot.ext = gtf_file,
  isGTFAnnotationFile = TRUE,
  isPairedEnd = FALSE, # FALSE because alignment was done in single-end mode
  GTF.featureType = "exon",    #count reads overlapping exons
  GTF.attrType = "gene_id",    #group counts by gene ID
  nthreads = 8                 #ise 8 threads to speed up counting
)


count_table <- gene_counts$counts
colnames(count_table) <- gsub("_sorted.bam", "", colnames(count_table)) #remove the "_sorted.bam" suffix

#filter out genes w/no reads
count_table <- count_table[rowSums(count_table) > 0, ]


DT::datatable(count_table,
          caption = "Gene Read Counts per Sample (Filtered)",
          options = list(pageLength = 10, autoWidth = TRUE))
```

### 5.5 SAMPLE-WISE CORRELATION ANALYSIS + CLUSTERING
### 5.5.1 Data prep for DESeq2
```{r}
library(DESeq2)

#Get the metadata table that would accompany the count table
coldata <- meta_data %>% dplyr::select(SampleName,SampleLong,Factor) %>% 
  dplyr::mutate(SampleLong=str_split_i(SampleLong, "\\.",1)) %>% #getting the groups name (Avirulent, Mock and Virulent)
  dplyr::rename(condition = SampleLong) %>%
  dplyr::mutate(condition = factor(condition)) %>% #for group comp
  dplyr::mutate(Factor = factor(Factor)) #for sample comp
  
base::rownames(coldata) <- coldata$SampleName
coldata <- coldata %>% mutate(SampleName = factor(SampleName))

coldata$type <- factor(rep("single-read", nrow(coldata)))

#Make sure samples are in the same order between the two. 
coldata <- coldata[base::match(base::colnames(count_table), rownames(coldata)),]

#Check that they are indeed same order
all(rownames(coldata) == base::colnames(count_table))
```
```{r}
#creating a dds object where the conditions are avr vs mock vs vir

dds1 <- DESeqDataSetFromMatrix(countData = count_table,
                              colData = coldata,
                              design = ~ condition)
```
```{r}
#creating a dds object where the conditions are the samples themslevs 
dds2 <- DESeqDataSetFromMatrix(countData = count_table,
                              colData = coldata,
                              design = ~ Factor)
```
### 5.5.2 Sample correlation based on transcript abundance table
```{r}
#correlating the samples
d <- cor(assay(rlog(dds1)), method = "spearman")
#turning correlation to a distance (1 - correlation) and clustring
hc <- hclust(dist(1 - d))

#hirarchal clustering
plot.phylo(as.phylo(hc), type = "p", edge.col = "blue", edge.width = 2,
             show.node.label = TRUE, no.margin = TRUE)
```
### 5.5.3 Analyzing DGE w/DESeq2
```{r}
dds1_results <- DESeq(dds1)
```
```{r}
dds2_results <- DESeq(dds2)
```
```{r}
res1 <- DESeq2::results(dds1_results)
res1
```
```{r}
res2 <- DESeq2::results(dds2_results)
res2
```
```{r}
dds2
```
### 5.5.3.1 Comparing Vir, Mock, and Avr broad overview
```{r}
res_vir_mock <- DESeq2::results(dds1_results, contrast = c("condition", "Vir", "Mock"), alpha = 0.2)

# Avr vs Mock  
res_avr_mock <- DESeq2::results(dds1_results, contrast = c("condition", "Avr", "Mock"), alpha = 0.2)

# Vir vs Avr
res_vir_avr <- DESeq2::results(dds1_results, contrast = c("condition", "Vir", "Avr"), alpha = 0.2)

# Function to filter and count DE genes
filter_and_count <- function(res_obj, comparison_name, fc_threshold = 2) {
  # Remove NAs
  res_filtered <- res_obj[!is.na(res_obj$padj) & !is.na(res_obj$log2FoldChange), ]
  
  # Apply filters: |log2FC| >= log2(2) = 1 and padj <= alpha (already set in results())
  sig_genes <- res_filtered[abs(res_filtered$log2FoldChange) >= log2(fc_threshold), ]
  
  # Count up and down regulated
  up_regulated <- sum(sig_genes$log2FoldChange > 0)
  down_regulated <- sum(sig_genes$log2FoldChange < 0)
  
  return(data.frame(
    Comparison = comparison_name,
    Up_regulated = up_regulated,
    Down_regulated = down_regulated
  ))
}

# Apply filtering and counting to all comparisons
results_summary <- rbind(
  filter_and_count(res_vir_mock, "Vir vs Mock"),
  filter_and_count(res_avr_mock, "Avr vs Mock"),
  filter_and_count(res_vir_avr, "Vir vs Avr")
)

# Print summary
print("Summary of DE genes (FC >= 2, alpha = 0.2):")
```
```{r}
print(results_summary)
```
```{r}
plot_data <- results_summary %>%
  pivot_longer(cols = c(Up_regulated, Down_regulated), 
               names_to = "Regulation", 
               values_to = "Count") %>%
  mutate(Regulation = factor(Regulation, levels = c("Up_regulated", "Down_regulated")))

# Create horizontal stacked bar plot
p <- ggplot(plot_data, aes(x = Comparison, y = Count, fill = Regulation)) +
  geom_bar(stat = "identity", position = "stack") +
  coord_flip() +  # Makes it horizontal
  labs(
    title = "Differentially Expressed Genes by Comparison",
    subtitle = "Fold Change >= 2, alpha = 0.2",
    x = "Comparison",
    y = "Number of Genes",
    fill = "Regulation"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    legend.title = element_text(size = 11),
    legend.text = element_text(size = 10))
p
```
```{r, eval = FALSE}
#CANT BE FINE IN MY LIBRARY
comp <- systemPipeR::readComp("~/Library/R/arm64/4.4/library/systemPipeRdata/extdata/param/targetsPE.txt")
comp[[1]]
```
```{r}
#using this code as alternative to above
targets_path <- system.file("extdata", "param", "targetsPE.txt", package = "systemPipeRdata")
comp <- systemPipeR::readComp(file = targets_path, format = "matrix", delim = "-")
comparison_pairs <- comp[[1]]
comparison_pairs
```
```{r}
results_list <- list()

for (i in 1:nrow(comparison_pairs)) {
  
  group1 <- comparison_pairs[i, 1]
  group2 <- comparison_pairs[i, 2]
  
  comparison_name <- paste(group1, "vs", group2)
  
  res <- DESeq2::results(dds2_results, contrast = c("Factor", group1, group2), alpha = 0.2)
  
  filtered_results <- filter_and_count(res, comparison_name)
  
  results_list[[comparison_name]] <- filtered_results
}

de_summary_by_factor <- do.call(rbind, results_list)

plot_data <- de_summary_by_factor %>%
  tidyr::pivot_longer(cols = c(Up_regulated, Down_regulated),
                      names_to = "Regulation",
                      values_to = "Count")

ggplot(plot_data, aes(x = Comparison, y = Count, fill = Regulation)) +
  geom_bar(stat = "identity", position = "stack") +
  coord_flip() +
  scale_fill_manual(values = c("Up_regulated" = "brown", "Down_regulated" = "lightblue")) +
  labs(
    title = "Differentially Expressed Genes by Sample Factor",
    subtitle = "Fold Change >= 2, Alpha <= 0.2",
    x = "Comparison",
    y = "Number of Differentially Expressed Genes"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title.position = "plot")
```
### 5.5.3.3 Adding gene descriptions and volcano plots
```{r}
m <- biomaRt::useMart("plants_mart", dataset = "athaliana_eg_gene",
               host = "https://plants.ensembl.org")
desc <- biomaRt::getBM(attributes = c("tair_locus", "description"), mart = m)
desc <- desc[!duplicated(desc[, 1]), ]
desc <- desc %>% rename( gene_id = tair_locus)

annotate_results <- function(res_obj, desc_df) {
  res_df <- as.data.frame(res_obj)
  res_df$gene_id <- rownames(res_df)
  res_df <- left_join(res_df, desc_df, by = "gene_id") %>%
    mutate(description = str_split_i(description,"\\[",1)) # <-- remove the source of the annotation from the description

  return(res_df)
}

# Add annotations to all results
res_vir_mock_annot <- annotate_results(res_vir_mock, desc)
res_avr_mock_annot <- annotate_results(res_avr_mock, desc)
res_vir_avr_annot <- annotate_results(res_vir_avr, desc)


volcano1 <- EnhancedVolcano(res_vir_mock_annot,
                           lab = res_vir_mock_annot$description,
                           x = 'log2FoldChange',
                           y = 'pvalue',
                           title = 'Vir vs Mock',
                           pCutoff = 0.05,           # pvalue threshold
                           FCcutoff = 1.0,
                           pointSize = 4.0,
                           labSize = 4.0,
                           labCol = 'black',
                           labFace = 'bold',
                           boxedLabels = TRUE,
                           colAlpha = 4/5,
                           legendPosition = 'right',
                           legendLabSize = 14,
                           legendIconSize = 4.0,
                           drawConnectors = TRUE,
                           widthConnectors = 1.0,
                           colConnectors = 'black') + ggplot2::scale_y_continuous(
      breaks=seq(0,4, 1))
```
```{r}
volcano1
```
```{r}
volcano2 <- EnhancedVolcano(res_vir_avr_annot,
                           lab = res_vir_avr_annot$description,
                           x = 'log2FoldChange',
                           y = 'pvalue',
                           title = 'Vir vs avir',
                           pCutoff = 0.05,           # pvalue threshold
                           FCcutoff = 1.0,
                           pointSize = 4.0,
                           labSize = 4.0,
                           labCol = 'black',
                           labFace = 'bold',
                           boxedLabels = TRUE,
                           colAlpha = 4/5,
                           legendPosition = 'right',
                           legendLabSize = 14,
                           legendIconSize = 4.0,
                           drawConnectors = TRUE,
                           widthConnectors = 1.0,
                           colConnectors = 'black')  + ggplot2::scale_y_continuous(
      breaks=seq(0,7, 1))
```
```{r}
volcano2
```
```{r}
volcano3 <- EnhancedVolcano(res_avr_mock_annot,
                           lab = res_avr_mock_annot$description,
                           x = 'log2FoldChange',
                           y = 'pvalue',
                           title = 'Avr vs Mock',
                           pCutoff = 0.05,           # pvalue threshold
                           FCcutoff = 1.0,
                           pointSize = 4.0,
                           labSize = 4.0,
                           labCol = 'black',
                           labFace = 'bold',
                           boxedLabels = TRUE,
                           colAlpha = 4/5,
                           legendPosition = 'right',
                           legendLabSize = 14,
                           legendIconSize = 4.0,
                           drawConnectors = TRUE,
                           widthConnectors = 1.0,
                           colConnectors = 'black') + ggplot2::scale_y_continuous(
      breaks=seq(0,4, 1))
```
```{r}
volcano3
```
### 5.5.4 Clustered heatmap
# QUESTION 8
When using Spearman correlation, our analysis was noisy as we were not only taking into account genes affected by the pathogen by those who WEREN'T as well. On the other hand, DEG clustering only takes into account the genes of interest that are directly affected by the pathogen. This allows us to better sample into treatment groups (virulent, avirulent, mock) and distinguish their gene expression patterns clearly (if there even is one - which there are in this case). For instance, mock treatments would only display baseline gene expression whereas avirulent groups would carry stronger gene expression, particularly those involved in plant defense pathways.


